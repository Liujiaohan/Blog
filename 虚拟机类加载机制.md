# 虚拟机类加载机制

## 类加载的时间

类被加载到虚拟机内存中开始，到卸载出内存位置，生命周期包括Loading(加载)、Verification(验证)、Preparetion(准备)、Resolution(解析)、Initialzation(初始化)、Using(使用)、Unloading(卸载)。其中Loading、Verification、Preparation、Initialzation、Unload的顺序是固定的、解析则不固定。

## 类加载过程

* Loading

  * 通过一个类的全限定名来获取定义此类的二进制字节流
  * 将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构
  * 在内存中生成一个代表这个类的Java.lang.Class 对象，作为**方法区 **这个类各项数据的访问入口

* Verification

  * 文件格式验证
  * 元数据验证
  * 字节码验证
  * 符号引用验证

  为了虚拟机自身的安全

* preparation

  * 准备阶段正式为类变量分配内存，并设置类变量初始值的结果，如public static int value=123，准备阶段为0

* 解析

  * 解析阶段是虚拟机将常量池中的符号引用**替换**为直接引用的过程

    * 符号引用以一组符号来描述所引用的目标，符号可以是任何形式的字面量，只要使用时能够无歧义的定位到目标即可。例如，在Class文件中它以CONSTANT_Class_info、CONSTANT_Fieldref_info、CONSTANT_Methodref_info等类型的常量出现。符号引用与虚拟机的内存布局无关，引用的目标并不一定加载到内存中。在Java中，一个java类将会编译成一个class文件。在编译时，java类并不知道所引用的类的实际地址，因此只能使用符号引用来代替。比如org.simple.People类引用了org.simple.Language类，在编译时People类并不知道Language类的实际内存地址，因此只能使用符号org.simple.Language（假设是这个，当然实际中是由类似于CONSTANT_Class_info的常量来表示的）来表示Language类的地址。各种虚拟机实现的内存布局可能有所不同，但是它们能接受的符号引用都是一致的，因为符号引用的字面量形式明确定义在Java虚拟机规范的Class文件格式中。

    * 直接引用可以是

      （1）直接指向目标的指针（比如，指向“类型”【Class对象】、类变量、类方法的直接引用可能是指向方法区的指针）

      （2）相对偏移量（比如，指向实例变量、实例方法的直接引用都是偏移量）

      （3）一个能间接定位到目标的句柄

      直接引用是和虚拟机的布局相关的，同一个符号引用在不同的虚拟机实例上翻译出来的直接引用一般不会相同。如果有了直接引用，那引用的目标必定已经被加载入内存中了。

  * 类或接口的解析

  * 字段解析

  * 接口方法解析

* 初始化

  初始化阶段才开始执行类中定义的Java程序代码，初始化阶段是执行类构造器**<clinit>()**方法的过程

  * <clinit> 编译器自动收集类中的所有类变量的赋值操作和静态语句块，虚拟机保证子类的<clinit>执行时父类的已执行完成，这和<init>不一样

## 类加载器

* 类与类加载器

  任意一个类都需要由加载它的类加载器和这个类本身一同确定其在Java虚拟的唯一性，每一个类加载器，都拥有一个独立的类名称空间

* 双亲委派模型

  * 启动类加载器

  * 扩展类加载器

  * 应用程序类加载器：自定义的类加载器继承自这个加载器

    ![双亲委派模型](http://img.blog.csdn.net/20160506184936657)

* 破坏双亲委派模型

  * 代码热替换（HotSwap）、模块热部署（Hot Deployment）
  * OSGi 双亲委派模型发展为复杂的网状结构