# 自动内存管理机制

## Java内存区域

* 程序计数器：线程私有，当前线程锁执行的字节码的行号指示器
* Java虚拟机栈：线程私有，它的生命周期与线程相同，Java方法在执行时创建一个栈帧用于存储局部变量表、操作数栈、动态链接、方法出口等信息。方法的调用和执行完成对应栈帧的出入
* 本地方法栈：相当于native方法的Java虚拟机栈
* Java堆：所有线程共享，存放对象实例
* 方法区：线程共享，储存已被虚拟机加载的类信息、常量、静态变量。堆的一个逻辑部分
* 运行时常量池：方法区的一部分，class文件中的常量池用于存放编译期生成的各种字面量和符号引用，这部分被加载后进入方法区的运行时常量池
* 直接内存：NIO中使用Native函数直接分配堆外内存，然后通过一个储存在Java堆中的DirectByteBuffer对象作为这块内存的引用

# 垃圾收集器和内存分配策略

## 对象已死的判断方法

* 引用计数算法：给对象添加一个引用计数器，有引用时计数器+1，引用失效是，计数器值-1，为零时表示不可能再被使用，但对于循环引用会有问题啊
* 可达性分析算法：通过一系列“GC Roots”对象作为起始点，从这些节点开始向下搜索，走过的路径成为“引用链”，当对象到达“GC Roots”没有引用链是证明对象可回收
* 引用：如果reference类型的数据中存储的数值代表的是另一块内存的其实地址，成为引用
  1. 强引用：Object o=new Object() 只要强引用还存在，GC永远不会回收掉该对象
  2. 软引用：描述还有用但非必须的对象，当系统GC发现内存不够时会回收
  3. 弱引用：描述非必须的对象，弱引用对象只能生存到下一次GC时
  4. 虚引用：一个对象是否有虚引用的存在，完全不会对其生存时间构成影响，也无法通过虚引用取得一个对象的实例
* 生存还是死亡：当发现对象 可回收时会把它加入F-Queue队列中，并在稍后由一个优先级虚拟机自动创建的优先级低的Finalizer线程去执行它，调用对象的finalize（）方法，你可以在这个方法中抢救一下让他不能回收
* 回收方法区：
  1. 废弃常量：当没有任何对象引用常量池中的常量可回收
  2. 无用的类：需满足以下条件
     * 该类所有实例被回收
     * 该类的Classloader被回收
     * 该类的Class对象没有在任何地方被引用，防止之后以反射机制调用该类

## 垃圾收集算法

* 标记清除算法：
  1. 标记处回收的对象后清除所标记的对象 
     * 缺点：1. 效率问题  2. 空间问题，太多碎片空间
* 复制算法：
  1. 先标记，然后把要保留的对象复制到另一块空间中 
     * 缺点： 1. 浪费空间
  2. 将内存分为Eden和两块Survivor（8:1:1）新生代中将Eden和Survivor中还存活的对象一次性复制到另一块Survivor中，当Survivor中内存不够时，需要一来老年代进行分配担保
* 标记清理算法：
  1. 标记完后，让所有存货对象向一段移动，然后直接清理掉端边界以外的内存
* 分代收集算法：
  1. 内存划分为几块，一般为老年代和新生代，对不同对象采用不同算法
     * 新生代中发现有大批对象死去，只有少量存活采用复制算法
     * 老年代中因为对象存活率高、没有额外空间采用标记清理或者标记整理
* Hotspot的算法实现
  1. 枚举根节点，进行GC时要Stop the world，停止所有Java执行线程
  2. 安全点：程序执行时可以停顿的地方
     * 抢先式中断：GC发生时，所有线程中断，判断是否在安全点，否则跑到安全点上，不需要和线程配合
     * 主动式中断：GC通过设置一个标志，线程不断轮询，中断标志为真时自动挂起线程，轮询标志的地方与安全点重合
  3. 安全区域：在这个区域中的任何地方GC都是安全的

## 垃圾收集器

* Serial收集器：单线程收集器，进行收集时必须暂停其他所有的工作线程，对于运行在Client模式下的虚拟机是一个很好的选择

* ParNew收集器：多线程版本额Serial收集器，但在单CPU中效率没有Serial收集器高

* Parallel Scavenge收集器：新生代收集器，使用复制算法，并行的多线程收集器，是吞吐量（运行用户代码时间/（运行用户代码时间+垃圾收集时间））优先的机器，GC停顿时间缩短是以牺牲吞吐量和新生代空间换取的，无法与CMS配合运行

* Serial Old收集器：Serial收集器的老生代版本，标记整理算法

* Parallel Old收集器：Parallel Scavenge的老生代版本

* CMS收集器（Concurrent Mark Sweep）：是一种以获得最短收集停顿时间为目标的收集器包括一下步骤：

  1. 初始标记：标记GCRoot能直接关联到的对象
  2. 并发标记：进行GC Roots Tracing
  3. 重新标记：修正并发标记过程中用户程序运行而导致标记变动的那一部分对象的标记记录
  4. 并发清除

  优点：

  * CMS收集器中时间最长的并发标志并发清除过程与用户线程一起工作，所以停顿时间比较短，总的说就是并发收集，地停顿

  缺点：

  * 对cpu资源敏感
  * 无法处理浮动垃圾
  * 因为使用标记清楚算法，所以会产生大量的空间碎片

* G1收集器：G1收集器是一种面向服务端应用的垃圾收集器

  特点：

  * 并行与并发
  * 分代收集
  * 空间整合：整体使用标记整理算法，也有部分使用复制算法，运作期间不会产生空间碎片
  * 可预测的停顿

  它将堆分成了几个Region，新生代和老生代不再是物理隔离而是一部分Region的集合，G1根据各个Region垃圾堆积价值后天维护一个优先队列，优先回收价值大的Region。每个Region都有一个RecommendSet来避免全堆扫描

  过程：

  * 初始标记：标记GC Roots能直接关联的对象
  * 并发标记：进行可达性分析
  * 最终标记：修正并发标记的是改变的
  * 筛选回收

## 内存分配和回收策略

* 对象优先在Eden分配，空间不足时发起一次MinorGC（新生代GC，Major GC指老年代GC，Full GC指整个堆的GC）
* 大对象直接进入老年代
* 长期存活的对象将进入老年代
* 动态对象年龄判断：如果在Survivor空间中相同年龄所有的对象大小的总和大于Survivor空间的一半，年龄大于或等于该年龄的对象就可以直接进入老年代
* 空间分配担保：只要老年代的连续空间大于新生代对象总大小或者历次晋升的平均大小就会进行MirrorGC，否则进行Full GC